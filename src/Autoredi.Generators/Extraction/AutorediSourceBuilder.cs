using System.Text;

namespace Autoredi.Generators.Extraction;

/// <summary>
/// Generates the IServiceCollection extension methods for Autoredi registrations.
/// </summary>
internal static class AutorediSourceBuilder
{
    public static string Generate(ImmutableArray<ServiceRegistration> registrations, string @namespace, string assemblyName)
    {
        var builder = new SourceBuilder();
        builder.AutoGenerated();
        builder.Using("Microsoft.Extensions.DependencyInjection");
        builder.Using("Microsoft.Extensions.DependencyInjection.Extensions");
        builder.Line();

        builder.Namespace(@namespace);

        builder.Class("public static", "AutorediServiceCollectionExtensions");
        builder.Block(b =>
        {
            GenerateDefaultServicesMethod(b, registrations);

            var groups = registrations
                .Where(r => !string.IsNullOrEmpty(r.Group))
                .Select(r => r.Group!)
                .Distinct()
                .OrderBy(g => g);

            foreach (var group in groups)
            {
                GenerateGroupExtensionMethod(b, registrations, group);
            }

            GenerateAssemblyWideServicesMethod(b, registrations, assemblyName);
        });

        return builder.ToString();
    }

    private static void GenerateDefaultServicesMethod(SourceBuilder builder, ImmutableArray<ServiceRegistration> registrations)
    {
        GenerateDefaultServicesDocComment(builder);
        builder.Method("public static", "IServiceCollection", "AddAutorediServices", "this IServiceCollection services");
        builder.Block(b =>
        {
            var defaultRegistrations = registrations
                .Where(r => string.IsNullOrEmpty(r.Group))
                .OrderByDescending(r => r.Priority)
                .ThenBy(r => r.ImplementationType);

            foreach (var reg in defaultRegistrations)
            {
                GenerateRegistration(b, reg);
            }

            b.Line("return services;");
        });
        builder.Line();
    }

    private static void GenerateAssemblyWideServicesMethod(SourceBuilder builder, ImmutableArray<ServiceRegistration> registrations, string assemblyName)
    {
        GenerateFullAssemblyServicesDocComment(builder, assemblyName);
        var assemblySuffix = ToIdentifierFragment(assemblyName);
        builder.Method("public static", "IServiceCollection", $"AddAutorediServices{assemblySuffix}", "this IServiceCollection services");
        builder.Block(b =>
        {
            var orderedRegistrations = registrations
                .OrderByDescending(r => r.Priority)
                .ThenBy(r => r.ImplementationType);

            foreach (var reg in orderedRegistrations)
            {
                GenerateRegistration(b, reg);
            }

            b.Line("return services;");
        });
        builder.Line();
    }

    private static void GenerateGroupExtensionMethod(SourceBuilder builder, ImmutableArray<ServiceRegistration> registrations, string group)
    {
        builder.Method("public static", "IServiceCollection", $"AddAutorediServices{group}", "this IServiceCollection services");
        builder.Block(b =>
        {
            var groupRegistrations = registrations
                .Where(r => r.Group == group)
                .OrderByDescending(r => r.Priority)
                .ThenBy(r => r.ImplementationType);

            foreach (var reg in groupRegistrations)
            {
                GenerateRegistration(b, reg);
            }

            b.Line("return services;");
        });
        builder.Line();
    }

    private static void GenerateDefaultServicesDocComment(SourceBuilder builder)
    {
        builder.Line("/// <summary>");
        builder.Line("/// Registers the default (ungrouped) Autoredi services from this assembly.");
        builder.Line("/// </summary>");
        builder.Line("/// <remarks>If no groups are defined, this method registers every service emitted by the assembly.</remarks>");
    }

    private static void GenerateFullAssemblyServicesDocComment(SourceBuilder builder, string assemblyName)
    {
        builder.Line("/// <summary>");
        builder.Line($"/// Registers every Autoredi service emitted by {assemblyName} (all groups included).");
        builder.Line("/// </summary>");
    }

    private static string ToIdentifierFragment(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return "Default";
        }

        var builder = new StringBuilder(value.Length + 1);
        var word = new StringBuilder();

        foreach (var ch in value)
        {
            if (char.IsLetterOrDigit(ch))
            {
                word.Append(ch);
                continue;
            }

            AppendWord(builder, word);
        }

        AppendWord(builder, word);

        if (builder.Length == 0)
        {
            return "Default";
        }

        if (!char.IsLetter(builder[0]) && builder[0] != '_')
        {
            builder.Insert(0, '_');
        }

        return builder.ToString();
    }

    private static void AppendWord(StringBuilder builder, StringBuilder word)
    {
        if (word.Length == 0)
        {
            return;
        }

        var first = word[0];
        builder.Append(char.ToUpperInvariant(first));

        if (word.Length > 1)
        {
            builder.Append(word.ToString(1, word.Length - 1));
        }

        word.Clear();
    }

    private static void GenerateRegistration(SourceBuilder builder, ServiceRegistration reg)
    {
        var method = (reg.Lifetime, reg.ServiceKey) switch
        {
            (ServiceLifetime.Singleton, null) => "AddSingleton",
            (ServiceLifetime.Scoped, null) => "AddScoped",
            (ServiceLifetime.Transient, null) => "AddTransient",
            (ServiceLifetime.Singleton, _) => "AddKeyedSingleton",
            (ServiceLifetime.Scoped, _) => "AddKeyedScoped",
            (ServiceLifetime.Transient, _) => "AddKeyedTransient",
            _ => "AddTransient"
        };

        var typeArgs = string.IsNullOrEmpty(reg.InterfaceType)
            ? $"<{reg.ImplementationType}>"
            : $"<{reg.InterfaceType}, {reg.ImplementationType}>";

        var keyArg = string.IsNullOrEmpty(reg.ServiceKey) ? "" : $"\"{reg.ServiceKey}\"";

        builder.Line($"services.{method}{typeArgs}({keyArg});");
    }
}
